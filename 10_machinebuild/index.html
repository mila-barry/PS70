<!DOCTYPE html>
<html lang="en">

<title>PS70: Intro to Digital Fabrication </title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="../style.css" rel="stylesheet">


<nav class="navbar navbar-expand-sm navbar-light bg-light">
  <div style="align-items: left; justify-content:left;" class="container-fluid">
    <h3 class="nav-title"> PS70: Intro to Digital Fabrication</h3>
    <div class="navbar-nav">
      <h4></h4>
      <h4><a class="nav-link" href="../index.html">Home</a></h4>
      <h4><a class="nav-link" href="../about.html">About</a></h4>
      <h4><a class="nav-link" href="./final_project.html">Brainstorm</a></h4>
    </div>
  </div>
</nav>

<body>


<xmp style="display:none;">
<br> 

#### Week 10: Team Drawing Machine

<span>Mechanical</span>
Mechanically, our team decided to design a plotter similar to that of the example plotter (3D model shown below). The plotter consists of 4 wheels, 3 stepper motors, a belt, and the other components are structural to make sure that our system operated with the correct play and that it could be as precise as possible for the electrical team to implement their code. 

We decided to cut most of our structural pieces out of wood. This gave our end product a rustic look and we thought that even though there were other materials that might have been sturdier or more durable, cutting wood using the ShopBot got the job done. 

For the wheels, we used laser cut acrylic gears that were mounted on the stepper and secured them to the 2 side stepper motors.

Additionally, we used two 2 foot metal rails to secure the sets of wheels together (like a pallet dolly) and secured the 3rd stepper motor to the side of one rail to act as the pulley for the belt system. We attached the belt so that there was enough tension so the end effector stayed secure, but not too much tension to the point where the end effector couldn’t move.

As for the end effector, Fabian had the brilliant idea to use a solenoid and potentiometer to create a pointillism-inspired dotter. The basic concept is that when the potentiometer is turned to a certain setting, the solenoid rapidly picks the pen up and down on the paper to make dotted lines and images.  

![close](./closewheel.jpg)
![bboard](./bboard.jpg)
![full](./full.jpg)
![stepper](./stepper.jpg)
![full2](./full2.jpg)

<span>Electrical</span>
Please see our code below! :) Special shoutout to Allen & Fatema for staying late and coming back for extra sessions to get the issues worked out! 

<pre><code class="language-arduino">
#include <AccelStepper.h>
#include <MultiStepper.h>
#include <math.h>

#define NUM_POINTS 18

double coordinates[NUM_POINTS][2];

//step 25, dir 26 left motor
AccelStepper stepper1(1, 25, 26);

//step 4, dir 2 right motor
AccelStepper stepper2(1, 4, 2);

//step 12, dir 13 end effector
AccelStepper stepper3(1, 12, 13);

MultiStepper wheels;

int global_x = 0;
int global_y = 0;

void setup() {
  Serial.begin(9600);
  stepper1.setMaxSpeed(3000);
  stepper1.setAcceleration(000);
  stepper2.setMaxSpeed(3000);
  stepper2.setAcceleration(5000);
  stepper3.setMaxSpeed(3000);
  stepper3.setAcceleration(5000);

  wheels.addStepper(stepper1);
  wheels.addStepper(stepper2);
  wheels.addStepper(stepper3);

}

void loop()
{
  long positions[2];
  generateCircle();

  printf("Going to 0:\n");
  global_x = map(0, -9, 9, -12500, 12500);
  global_y = map(0, -9, 9, -12500, 12500);
  positions[0] = global_y;
  positions[1] = -global_y;
  positions[2] = global_x;
  wheels.moveTo(positions);
  wheels.runSpeedToPosition(); // Blocks until all are in position
  delay(100);

  printf("Coordinates of the circle:\n");
  for (int i = 0; i < NUM_POINTS; i++) {
      printf("(%lf, %lf)\n", coordinates[i][0], coordinates[i][1]);
      global_x = map(coordinates[i][0], -9, 9, -12500, 12500);
      global_y = map(coordinates[i][1], -9, 9, -12500, 12500);
      positions[0] = global_y;
      positions[1] = -global_y;
      positions[2] = global_x;
      wheels.moveTo(positions);
      wheels.runSpeedToPosition(); // Blocks until all are in position
      delay(100);
  }

  printf("Going to 0:\n");
  global_x = map(0, -9, 9, -12500, 12500);
  global_y = map(0, -9, 9, -12500, 12500);
  positions[0] = global_y;
  positions[1] = -global_y;
  positions[2] = global_x;
  wheels.moveTo(positions);
  wheels.runSpeedToPosition(); // Blocks until all are in position
  delay(100);

//  long positions[2];
//
//  positions[0] = 0;
//  positions[1] = 0;
//  positions[2] = 1000;
//  wheels.moveTo(positions);
//  wheels.runSpeedToPosition(); // Blocks until all are in position
//  delay(1000);
//
////   Move to a different coordinate
//  positions[0] = 0;
//  positions[1] = 0;
//  positions[2] = -1000;
//  wheels.moveTo(positions);
//  wheels.runSpeedToPosition(); // Blocks until all are in position
//  delay(1000);
//
////
//  if (stepper1.distanceToGo() == 0) {
//    Serial.println("Moving Stepper 1 in 1 second");
//    stepper1.moveTo(rand() % 10000);
//  }
//  stepper1.run();
//  if (stepper2.distanceToGo() == 0) {
//    Serial.println("Moving Stepper 2 in 1 second");
//    stepper2.moveTo(rand() % 10000);
//  }
//  stepper2.run();
//  if (stepper3.distanceToGo() == 0) {
//    Serial.println("Moving Stepper 3 in 1 second");
//    stepper3.moveTo(rand() % 10000);
//  }
//  stepper3.run();
}

void generateCircle() {
    int radius = 9;
    double angle = 0;
    double angleIncrement = 2 * M_PI / NUM_POINTS; // Angle increment for each point
    int i;

    for (i = 0; i < NUM_POINTS; i++) {
        coordinates[i][0] = radius * cos(angle); // x = r * cos(theta)
        coordinates[i][1] = radius * sin(angle); // y = r * sin(theta)
        angle -= angleIncrement; // Decreasing angle to move clockwise
    }
}
</code></pre>

</xmp>
</body>

<script src="../strapdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" ></script>

</html>